# Source Code Analysis: AI Pentesting Frameworks

**Date:** 2026-02-13
**Context:** Argos SDR & Network Analysis Console — Evaluating architectures for Claude Code integration
**Method:** Direct source code analysis from GitHub repositories

---

## Executive Summary

Four major open-source AI pentesting frameworks were analyzed at the source code level. They are **NOT all the same**. They range from a ~1,000-line wrapper around Claude Code (PentestGPT) to a ~15,000-line custom Go ReAct engine (PentAGI). The key finding: **PentestGPT proves Claude Code alone is sufficient as the agent loop**, while PentestAgent's planning and knowledge graph patterns are the most relevant additions for Argos.

---

## 1. Shannon (Keygraph) — Temporal + Claude Agent SDK

**Repo:** [KeygraphHQ/shannon](https://github.com/KeygraphHQ/shannon)
**Language:** TypeScript
**Core Dependencies:** `@anthropic-ai/claude-agent-sdk ^0.2.38`, `@temporalio/workflow ^1.11.0`, `zx ^8.0.0`

### Architecture

Shannon uses **Temporal** (a durable workflow engine) to orchestrate a DAG of independent Claude Agent SDK sessions. It does NOT use Claude SDK's built-in multi-agent features.

```
Temporal Workflow (pentestPipelineWorkflow)
├── Pre-Recon: zx shell (nmap, subfinder, whatweb) + 1 Claude session
├── Recon: 1 Claude session (Bash + Browser)
├── 5x Parallel Temporal Activities:
│   ├── Vuln Agent (Claude session) → writes JSON queue file
│   ├── Queue Validation (TypeScript code, no LLM)
│   └── Exploit Agent (Claude session, conditional) → writes evidence
└── Reporting: File assembly (TypeScript) + 1 Claude session for executive summary
```

### How Tools Work

- **Pre-recon tools run directly via `zx`** (no LLM involvement):
    ```typescript
    case 'nmap': {
      result = await $({ silent: true })`nmap -sV -sC ${nmapHostname}`;
    }
    case 'subfinder': {
      result = await $({ silent: true })`subfinder -d ${hostname}`;
    }
    ```
- **Agent tools use Claude SDK's built-in Bash tool** — no custom nmap/curl wrappers
- **Only 2 custom MCP tools:** `save_deliverable` (write report) and `generate_totp` (2FA tokens)
- **5 Playwright browser instances** (one per OWASP category) via MCP

### Agent Loop

Claude SDK's default `query()`:

```typescript
const result = await query({
	model: 'claude-sonnet-4-5-20250514',
	maxTurns: 10000,
	permissionMode: 'bypassPermissions',
	systemPrompt: prompt,
	mcpServers: mcpServers
});
```

### "Proof by Exploitation"

1. Vuln agents write JSON queue: `{"vulnerabilities": [...]}`
2. TypeScript validation checks if queue is non-empty
3. Exploit agents read queue, attempt real exploitation against live target
4. Classify each: `EXPLOITED`, `BLOCKED_BY_SECURITY`, `FALSE_POSITIVE`, `OUT_OF_SCOPE_INTERNAL`
5. Only `EXPLOITED` and `BLOCKED_BY_SECURITY` appear in final report

### Key Differentiator

**Fault tolerance via Temporal:** Git checkpoint per agent, rollback on failure, 50 retry attempts with 5-30min intervals. Production-grade reliability.

**Cost:** ~$8-50/run (13 Claude Sonnet 4.5 sessions × hundreds of API calls each)

---

## 2. PentAGI (vxcontrol) — Custom Go ReAct Engine

**Repo:** [vxcontrol/pentagi](https://github.com/vxcontrol/pentagi)
**Language:** Go
**Core Dependencies:** Forked `langchaingo`, PostgreSQL + pgvector, Neo4j + Graphiti, Docker API

### Architecture

Everything is custom-built. The most complex framework analyzed.

```
Primary Agent (Go ReAct loop)
├── Tools: terminal, file, browser, 7 search engines
├── Delegates to sub-agents via tool calls:
│   ├── Pentester Agent → own ReAct loop
│   │   └── Can delegate to: Coder, Searcher, Memorist
│   ├── Coder Agent → own ReAct loop
│   ├── Installer Agent (DevOps)
│   ├── Searcher Agent (web + memory)
│   ├── Memorist Agent (long-term recall)
│   └── Adviser Agent (mentor/guidance)
├── Memory: pgvector + Neo4j/Graphiti + ChainAST
└── All commands in Docker containers (NET_RAW, NET_ADMIN)
```

### Agent Loop (Custom)

Hand-rolled in `performer.go`:

1. Call LLM with tools → parse tool calls → execute → append results → repeat
2. **Repeating call detector:** breaks loop if same tool+args called 3x
3. **Reflector agent:** secondary LLM call decides continue/stop when agent returns text instead of tool calls
4. **Results > 16KB auto-summarized** before returning to agent

### Memory System (3-Tier)

- **Long-term:** pgvector — tool results auto-chunked and embedded
- **Working:** ChainAST — message chain parsed into AST for selective summarization
- **Episodic:** Graphiti/Neo4j — temporal knowledge graph with entity tracking, attack path discovery

### Tool Registry

34+ tools in `registry.go`:

```go
var registryDefinitions = map[string]llms.FunctionDefinition{
    TerminalToolName: { ... },  // Docker exec
    FileToolName: { ... },      // File read/write
    BrowserToolName: { ... },   // Web browser
    // + pentester, coder, maintenance, search, memorist, advice (agent delegation)
    // + search_in_memory, search_guide, store_guide, graphiti_search (memory)
    // + google, duckduckgo, tavily, perplexity, searxng (web search)
    // + done, ask (barrier functions to end loop)
}
```

### Key Differentiator

**Knowledge graph:** Graphiti/Neo4j tracks entities (IPs, services, vulnerabilities) across engagements. 7 specialized search types including `SuccessfulToolsSearch` (what worked before) and attack path discovery.

**Cost:** Varies by model (default: OpenAI `o4-mini` — cheap)

---

## 3. PentestGPT (GreyDGL) — Claude Code Wrapper

**Repo:** [GreyDGL/PentestGPT](https://github.com/GreyDGL/PentestGPT)
**Language:** Python
**Core Dependencies:** `claude-agent-sdk >= 0.1.0`, `@anthropic-ai/claude-code` (npm, global install)

### Architecture

**PentestGPT v1.0 IS Claude Code.** The entire intelligence is delegated to Claude Code CLI.

```
PentestGPT Python Process (~1000 lines of custom code)
├── TUI (Textual): Monitoring display
├── Session Manager: JSON-based pause/resume
├── Langfuse Telemetry: Research data collection
└── Spawns Claude Code CLI subprocess
    ├── Claude Code's built-in agent loop
    ├── Claude Code's Bash tool (runs nmap, sqlmap, etc.)
    ├── Claude Code's File tools
    └── Model routing via claude-code-router proxy
        ├── default → OpenRouter GPT-5.1 (cheap)
        ├── think → OpenRouter GPT-5.1
        └── webSearch → Google Gemini 3 Pro
```

### How Tools Work

**Zero custom tools.** The `tools/` directory has only placeholder stubs:

```python
class TerminalTool(BaseTool):
    async def execute(self, command="", **kwargs):
        return {"success": True, "result": "Executed via Claude Code"}
```

All tool execution is Claude Code's built-in Bash tool. The Dockerfile installs pentest tools:

```dockerfile
RUN apt-get install -y nmap netcat-openbsd curl wget git sudo \
    net-tools dnsutils whois openvpn jq ripgrep tmux
RUN npm install -g @anthropic-ai/claude-code
```

### Agent Loop

Claude Code's default:

```python
options = ClaudeAgentOptions(
    cwd=str(self.config.working_directory),
    permission_mode="bypassPermissions",
    system_prompt=self._build_system_prompt(),
    model=self.config.llm_model,
)
self.client = ClaudeSDKClient(options=options)
await self.client.connect()
await self.client.query(task)
```

### Key Differentiator

**Cost efficiency via model routing:** `claude-code-router` intercepts Claude Code API calls and redirects to cheaper models. $1.11/run on OpenRouter vs $8-50 on Anthropic direct.

**Proof that Claude Code alone is sufficient** — USENIX Security 2024 paper, 86.5% success rate (90/104 benchmarks).

---

## 4. PentestAgent (GH05TCREW) — Plan-Driven ReAct + MCP + Knowledge Graph

**Repo:** [GH05TCREW/pentestagent](https://github.com/GH05TCREW/pentestagent)
**Language:** Python
**Core Dependencies:** LiteLLM, Playwright, NetworkX, Typer/Textual

### Architecture

Three modes: Assist (interactive), Agent (autonomous), Crew (multi-agent).

```
PentestAgent
├── Assist Mode: Single LLM call, user controls flow
├── Agent Mode: Plan-driven ReAct loop
│   ├── Iteration 1: Force plan generation (structured tool call)
│   ├── Iterations 2-N: Execute steps, track via finish tool
│   ├── On step failure: LLM replanning
│   └── Tools: terminal, browser, notes, web_search, MCP tools
└── Crew Mode: LLM Orchestrator
    ├── Tools: spawn_agent, wait_for_agents, cancel_agent, finish
    ├── Each worker: Full PentestAgentAgent with isolated runtime
    ├── Shadow Graph: Strategic insights from notes
    └── Playbooks: Structured attack templates
```

### Agent Loop (Plan-Driven)

**Phase 1 — Forced planning:** On iteration 1, forces the LLM to call `create_plan` tool, producing structured `PlanStep` objects.

**Phase 2 — Iterative execution:**

```python
response = await self.llm.generate(
    system_prompt=self.get_system_prompt("agent"),
    messages=self._build_messages(),
    tools=self.tools,
)
# Execute tool calls
# Check plan completion via finish tool
if self._task_plan.is_complete(): break
if self._task_plan.has_failure(): await self._replan()
```

### Shadow Graph (Knowledge Graph)

Auto-derived from agent notes using NetworkX:

```python
class ShadowGraph:
    def __init__(self):
        self.graph = nx.DiGraph()
    # Node types: host, service, credential, finding, vulnerability, endpoint
    # Edge types: CONNECTS_TO, HAS_SERVICE, AUTH_ACCESS, AFFECTED_BY
    # Auto-extracts IPs, ports, usernames, technologies via regex

    def get_strategic_insights(self) -> List[str]:
        # 1. Unused credentials: "We have creds for X, Y"
        # 2. High-value targets: "Host 10.0.0.1 has 3 services, 2 vulns"
        # 3. Attack paths: nx.shortest_path() for multi-step pivots
```

### MCP Integration (First-Class)

Three transport layers: stdio, SSE, WebSocket. MCP tools dynamically discovered and wrapped as native tools:

```python
def create_mcp_tool(tool_def, server, manager) -> Tool:
    # Names: mcp_{server_name}_{tool_name}
    # Execution: JSON-RPC 2.0 via transport layer
```

### Playbooks

Structured attack templates:

```python
class THP3ReconPlaybook(BasePlaybook):
    name = "thp3_recon"
    mode = "crew"  # Multi-agent execution
    phases = [
        Phase(name="Passive Reconnaissance", techniques=[...]),
        Phase(name="Active Reconnaissance", techniques=[...]),
    ]
```

### Environment Detection

Scans for 200+ tools across 16 categories using `shutil.which()`. Injects inventory into system prompt so the agent knows what's available.

### Smart Terminal

If LLM sends bare flags (`-sV -p 80 10.10.10.1`), pattern-matches to likely tool (nmap) and auto-prepends binary.

### Key Differentiator

**Most relevant architecture for Argos:** plan-driven execution (operator review), shadow graph (tactical map integration), MCP as first-class (already have 7 MCP servers), playbooks (structured military training scenarios), environment detection (knows what tools are on the RPi5).

---

## Comparison Matrix

| Feature             | Shannon                 | PentAGI                     | PentestGPT           | PentestAgent                    |
| ------------------- | ----------------------- | --------------------------- | -------------------- | ------------------------------- |
| **Custom code**     | ~5,000 lines            | ~15,000 lines               | ~1,000 lines         | ~8,000 lines                    |
| **Agent loop**      | Claude SDK default      | Custom Go ReAct             | Claude Code built-in | Custom plan-driven ReAct        |
| **Custom tools**    | 2 MCP                   | 34+ registry                | 0 (stubs)            | 5 built-in + MCP                |
| **Multi-agent**     | Temporal parallel       | Recursive delegation        | None                 | Crew worker pool                |
| **Memory**          | Filesystem              | pgvector + Neo4j + ChainAST | Claude Code context  | Notes + Shadow Graph + RAG      |
| **Knowledge graph** | None                    | Graphiti/Neo4j              | None                 | NetworkX auto-derived           |
| **Planning**        | Phase-based (hardcoded) | None (reactive)             | None                 | Forced plan generation + replan |
| **MCP support**     | Playwright only         | None                        | None                 | First-class (stdio/SSE/WS)      |
| **Model lock-in**   | Anthropic only          | Any provider                | Any (via router)     | Any (via LiteLLM)               |
| **Attack scope**    | Web apps (white-box)    | General                     | CTF/general          | General + wireless              |
| **Fault tolerance** | Temporal retry + git    | Reflector + repeat detect   | None                 | Replan on failure               |
| **Cost/run**        | $8-50                   | Varies                      | $1.11 (OpenRouter)   | Varies                          |

---

## Recommendation for Argos

### Use the PentestGPT Pattern as Base

Claude Code on Max plan IS the agent loop. PentestGPT proved this works at 86.5% benchmark success. Zero custom agent code needed.

### Add PentestAgent's Key Innovations

1. **Plan-driven execution** — Force plan generation before attack. Operator reviews plan on tactical map before approving. Maps to military C2 decision cycle (observe → orient → decide → act).

2. **Shadow Graph on tactical map** — As Claude Code discovers IPs, services, credentials, vulnerabilities, auto-build a NetworkX graph. Render this on the Argos Leaflet map as nodes and edges. Compute attack paths for the operator.

3. **MCP tool integration** — Argos already has 7 MCP servers. Add recon/attack MCP servers following the existing `BaseMCPServer` pattern.

4. **Playbooks for training scenarios** — Define structured attack templates for common training exercises (WiFi penetration, Bluetooth exploitation, GSM interception, network infiltration). Map to PentestAgent's Phase/Technique pattern.

5. **Environment detection** — Scan the RPi5 for available tools at startup, inject into Claude Code's context.

### Skip What You Don't Need

- **Temporal** (Shannon) — Overkill for single-operator use
- **Neo4j/Graphiti** (PentAGI) — NetworkX is sufficient; no need for a separate database
- **pgvector** (PentAGI) — SQLite is already in Argos; use it for memory
- **Custom ReAct loop** (PentAGI) — Claude Code's built-in loop is proven sufficient
- **Model routing** (PentestGPT) — Not needed on Max plan (unlimited Claude usage)

---

## References

- [Shannon - Keygraph (GitHub)](https://github.com/KeygraphHQ/shannon)
- [PentAGI - vxcontrol (GitHub)](https://github.com/vxcontrol/pentagi)
- [PentestGPT - GreyDGL (GitHub)](https://github.com/GreyDGL/PentestGPT)
- [PentestAgent - GH05TCREW (GitHub)](https://github.com/GH05TCREW/pentestagent)
- [Shannon Architecture (Medium)](https://medium.com/@parathan/proof-by-exploitation-shannons-approach-to-autonomous-penetration-testing-010eac3588d3)
- [PentAGI Architecture (DeepWiki)](https://deepwiki.com/vxcontrol/pentagi)
- [Open-Source AI Pentesting Tools Review (Help Net Security)](https://www.helpnetsecurity.com/2026/02/02/open-source-ai-pentesting-tools-test/)
- [Agentic Pentesting Guide (Escape.tech)](https://escape.tech/blog/agentic-pentesting/)
